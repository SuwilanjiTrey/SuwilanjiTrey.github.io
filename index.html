<script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // Museum room (walls, floor, ceiling)
        const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const wallGeometry = new THREE.PlaneGeometry(20, 10);
        const floorGeometry = new THREE.PlaneGeometry(20, 20);

        // Walls
        const walls = [
            { position: [0, 5, -10], rotation: [0, 0, 0] },
            { position: [-10, 5, 0], rotation: [0, Math.PI / 2, 0] },
            { position: [10, 5, 0], rotation: [0, -Math.PI / 2, 0] },
            { position: [0, 5, 10], rotation: [0, Math.PI, 0] }
        ];

        walls.forEach(wall => {
            const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
            wallMesh.position.set(...wall.position);
            wallMesh.rotation.set(...wall.rotation);
            scene.add(wallMesh);
        });

        // Floor
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Ceiling
        const ceiling = new THREE.Mesh(floorGeometry, wallMaterial);
        ceiling.position.y = 10;
        ceiling.rotation.x = Math.PI / 2;
        scene.add(ceiling);

        // Adjusted width for images and videos on walls
        const imageGeometry = new THREE.PlaneGeometry(5, 3);  // Adjust the size here (5 units wide, 3 units tall)

        // Pictures on walls
        const textureLoader = new THREE.TextureLoader();
        const pictureData = [
            { position: [0, 5, -9.9], rotation: [0, 0, 0], type: 'carousel', files: ['img1.png', 'img2.png', 'img3.png'] },
            { position: [-9.9, 5, 0], rotation: [0, Math.PI / 2, 0], type: 'video', element: 'gif1' },
            { position: [9.9, 5, 0], rotation: [0, -Math.PI / 2, 0], type: 'video', element: 'gif2' },
            { position: [0, 5, 9.9], rotation: [0, Math.PI, 0], type: 'video', element: 'gif3' }
        ];

        const videoTextures = [];
        let carouselIndex = 0;

        pictureData.forEach((pic, index) => {
            let material;
            
            if (pic.type === 'carousel') {
                const texture = textureLoader.load(`images/${pic.files[0]}`);
                material = new THREE.MeshBasicMaterial({ map: texture });
                
                // Create a simple carousel
                setInterval(() => {
                    carouselIndex = (carouselIndex + 1) % pic.files.length;
                    textureLoader.load(`images/${pic.files[carouselIndex]}`, (newTexture) => {
                        material.map = newTexture;
                        material.needsUpdate = true;
                    });
                }, 3000); // Change every 3 seconds
            } else if (pic.type === 'video') {
                const video = document.getElementById(pic.element);
                video.play(); // Start playing the video
                const videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                videoTexture.format = THREE.RGBFormat;
                material = new THREE.MeshBasicMaterial({ map: videoTexture });
                videoTextures.push(videoTexture);
            }
            
            const picture = new THREE.Mesh(imageGeometry, material);
            picture.position.set(...pic.position);
            picture.rotation.set(...pic.rotation);
            scene.add(picture);
        });

        // Pedestal with papers next to the central image
        const pedestalGeometry = new THREE.BoxGeometry(1.5, 3, 1.5);
        const pedestalMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
        const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
        pedestal.position.set(3, 1.5, -9.5);  // Adjust position as needed
        scene.add(pedestal);

        // Adding papers on top of the pedestal
        const paperGeometry = new THREE.PlaneGeometry(1, 1.5);
        const paperMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const paper = new THREE.Mesh(paperGeometry, paperMaterial);
        paper.position.set(3, 3, -9.5);
        paper.rotation.x = -Math.PI / 2;
        scene.add(paper);

        // Camera setup
        camera.position.set(0, 4, 0);
        camera.lookAt(0, 2, -1);

        // Mouse look variables
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        const sensitivity = 0.002;

        // Interactivity
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let intersectedObject = null;

        function checkIntersections() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...scene.children]);
            
            if (intersects.length > 0) {
                intersectedObject = intersects[0].object;
                document.getElementById('interactButton').style.display = 'block';
            } else {
                intersectedObject = null;
                document.getElementById('interactButton').style.display = 'none';
            }
        }

        function interact() {
            if (intersectedObject) {
                alert(`You interacted with an object at position (${intersectedObject.position.x.toFixed(2)}, ${intersectedObject.position.y.toFixed(2)}, ${intersectedObject.position.z.toFixed(2)})`);
            }
        }

        document.addEventListener('keydown', (event) => {
            const speed = 0.5;
            switch(event.code) {
                case 'ArrowUp':
                    camera.position.z -= Math.cos(camera.rotation.y) * speed;
                    camera.position.x -= Math.sin(camera.rotation.y) * speed;
                    break;
                case 'ArrowDown':
                    camera.position.z += Math.cos(camera.rotation.y) * speed;
                    camera.position.x += Math.sin(camera.rotation.y) * speed;
                    break;
                case 'ArrowLeft':
                    camera.position.x -= Math.cos(camera.rotation.y) * speed;
                    camera.position.z += Math.sin(camera.rotation.y) * speed;
                    break;
                case 'ArrowRight':
                    camera.position.x += Math.cos(camera.rotation.y) * speed;
                    camera.position.z -= Math.sin(camera.rotation.y) * speed;
                    break;
                case 'KeyE':
                    interact();
                    break;
            }
        });

        document.getElementById('interactButton').addEventListener('click', interact);

        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        document.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const movementX = event.clientX - mouseX;
                const movementY = event.clientY - mouseY;

                targetRotationX += movementX * sensitivity;
                targetRotationY += movementY * sensitivity;

                mouseX = event.clientX;
                mouseY = event.clientY;

                camera.rotation.y -= targetRotationX;
                camera.rotation.x -= targetRotationY;

                targetRotationX *= 0.9;
                targetRotationY *= 0.9;
            }

            // Update mouse coordinates for raycasting
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            checkIntersections();
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Animation
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate corner objects
            rotatingObjects.forEach(obj => {
                obj.rotation.x += 0.01;
                obj.rotation.y += 0.01;
            });
            
                        // Update video textures
            videoTextures.forEach(texture => {
                texture.needsUpdate = true;
            });


            // Smooth camera rotation
            camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.1;
            camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.1;
            
            checkIntersections();
            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
