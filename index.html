<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Museum Portfolio</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
        }
        #interactButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            display: none;
        }
    </style>
</head>
<body>
    <div id="info">Use arrow keys to move. Click and drag to look around.</div>
    <button id="interactButton">Interact (E)</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // Museum room (walls, floor, ceiling)
        const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const wallGeometry = new THREE.PlaneGeometry(20, 10);
        const floorGeometry = new THREE.PlaneGeometry(20, 20);

        // Walls
        const walls = [
            { position: [0, 5, -10], rotation: [0, 0, 0] },
            { position: [-10, 5, 0], rotation: [0, Math.PI / 2, 0] },
            { position: [10, 5, 0], rotation: [0, -Math.PI / 2, 0] },
            { position: [0, 5, 10], rotation: [0, Math.PI, 0] }
        ];

        walls.forEach(wall => {
            const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
            wallMesh.position.set(...wall.position);
            wallMesh.rotation.set(...wall.rotation);
            scene.add(wallMesh);
        });

        // Floor
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Ceiling
        const ceiling = new THREE.Mesh(floorGeometry, wallMaterial);
        ceiling.position.y = 10;
        ceiling.rotation.x = Math.PI / 2;
        scene.add(ceiling);

        // Pictures on walls
        // Pictures on walls
        const textureLoader = new THREE.TextureLoader();
        const pictureData = [
            { position: [0, 5, -9.9], rotation: [0, 0, 0], file: 'central.png' },  // Central image (PNG or JPEG)
            { position: [-9.9, 5, 0], rotation: [0, Math.PI / 2, 0], file: '1.gif' },  // Left wall (GIF)
            { position: [9.9, 5, 0], rotation: [0, -Math.PI / 2, 0], file: '2.gif' },  // Right wall (GIF)
            { position: [0, 5, 9.9], rotation: [0, Math.PI, 0], file: '3.jpg' }  // Back wall (GIF)
        ];

        pictureData.forEach((pic) => {
            const texture = textureLoader.load(`images/${pic.file}`);
            const pictureMaterial = new THREE.MeshBasicMaterial({ map: texture });
            const picture = new THREE.Mesh(new THREE.PlaneGeometry(3, 3), pictureMaterial);
            picture.position.set(...pic.position);
            picture.rotation.set(...pic.rotation);
            scene.add(picture);
        });


        // Rotating objects in corners
        const cornerPositions = [
            [-9, 1, -9],
            [9, 1, -9],
            [-9, 1, 9],
            [9, 1, 9]
        ];

        const rotatingObjects = cornerPositions.map((position, index) => {
            const geometry = index % 2 === 0 ? new THREE.BoxGeometry(1, 1, 1) : new THREE.TetrahedronGeometry(0.7);
            const material = new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff });
            const object = new THREE.Mesh(geometry, material);
            object.position.set(...position);
            scene.add(object);
            return object;
        });

        // Camera setup
        camera.position.set(0, 4, 0);
        camera.lookAt(0, 2, -1);

        // Mouse look variables
        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        const sensitivity = 0.002;

        // Interactivity
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let intersectedObject = null;

        function checkIntersections() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...rotatingObjects, ...scene.children]);
            
            if (intersects.length > 0) {
                intersectedObject = intersects[0].object;
                document.getElementById('interactButton').style.display = 'block';
            } else {
                intersectedObject = null;
                document.getElementById('interactButton').style.display = 'none';
            }
        }

        function interact() {
            if (intersectedObject) {
                alert(`You interacted with an object at position (${intersectedObject.position.x.toFixed(2)}, ${intersectedObject.position.y.toFixed(2)}, ${intersectedObject.position.z.toFixed(2)})`);
            }
        }

        document.addEventListener('keydown', (event) => {
            const speed = 0.5;
            switch(event.code) {
                case 'ArrowUp':
                    camera.position.z -= Math.cos(camera.rotation.y) * speed;
                    camera.position.x -= Math.sin(camera.rotation.y) * speed;
                    break;
                case 'ArrowDown':
                    camera.position.z += Math.cos(camera.rotation.y) * speed;
                    camera.position.x += Math.sin(camera.rotation.y) * speed;
                    break;
                case 'ArrowLeft':
                    camera.position.x -= Math.cos(camera.rotation.y) * speed;
                    camera.position.z += Math.sin(camera.rotation.y) * speed;
                    break;
                case 'ArrowRight':
                    camera.position.x += Math.cos(camera.rotation.y) * speed;
                    camera.position.z -= Math.sin(camera.rotation.y) * speed;
                    break;
                case 'KeyE':
                    interact();
                    break;
            }
        });

        document.getElementById('interactButton').addEventListener('click', interact);

        // Mouse events for looking around
        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        document.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                mouseX = event.clientX;
                mouseY = event.clientY;

                targetRotationY -= deltaX * sensitivity;
                targetRotationX -= deltaY * sensitivity;

                // Limit vertical rotation
                targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
            }
        });

        // Animation
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate corner objects
            rotatingObjects.forEach(obj => {
                obj.rotation.x += 0.01;
                obj.rotation.y += 0.01;
            });
            
            // Smooth camera rotation
            camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.1;
            camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.1;
            
            checkIntersections();
            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
